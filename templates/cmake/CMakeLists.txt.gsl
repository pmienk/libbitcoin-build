.template 0
###############################################################################
# Copyright (c) 2014-2025 libbitcoin developers (see COPYING).
#
# GSL generate libbitcoin CMakeLists.txt.
#
# This is a code generator built using the iMatix GSL code generation
# language. See https://github.com/imatix/gsl for details.
###############################################################################

###############################################################################
# Functions
###############################################################################
function registry(registrar, query)
    define my.registrar = registry.registrar
    define my.query = registry.query

    if !defined(my.query.name)
        abort("Malformed query: $(my.query)")
    endif

    return my.registrar->element(element.name = my.query.name)
endfunction

function package_name(query)
    define my.query = package_name.query
    define my.registry = registry(configuration->registrar(id = "dependency"), my.query)

    if !defined(my.registry)
        abort("Missing registry for $(my.query)")
    endif

    if !defined(my.registry->cmake) | !defined(my.registry->cmake.package)
        abort("Missing registry details for $(my.query)")
    endif

    return my.registry->cmake.package
endfunction

function qualified_component_name(dependency, component)
    define my.dependency = qualified_component_name.dependency
    define my.component = qualified_component_name.component
    define my.registry = registry(configuration->registrar(id = "dependency"), my.dependency)

    if !defined(my.registry)
        abort("Missing registry for $(my.dependency)")
    endif

    if !defined(my.registry->cmake) | !defined(my.registry->cmake.namespace)
        abort("Missing registry details for $(my.dependency)")
    endif

    if !defined(my.component) | !defined(my.component.name)
        abort("Component undefined or missing 'name' property.")
    endif

    return "$(my.registry->cmake.namespace)::$(my.component.name)"
endfunction

function qualified_target_name(query)
    define my.query = qualified_target_name.query
    define my.registry = registry(configuration->registrar(id = "dependency"), my.query)

    if !defined(my.registry)
        abort("Missing registry for $(my.query)")
    endif

    if !defined(my.registry->cmake) | !defined(my.registry->cmake.target)
        abort("Missing registry details for $(my.query)")
    endif

    return my.registry->cmake.target
endfunction

function target_name(element)
    if !defined(target_name.element.name)
        abort("Missing 'name'.")
    endif

    return target_name.element.name
endfunction

function language_list(repository)
    define my.repository = language_list.repository
    define my.result = ""

    for my.repository.language as _lang
        if (!is_empty(my.result))
            my.result = "$(my.result) $(_lang.id)"
        else
            my.result = "$(_lang.id)"
        endif
    endfor

    return my.result
endfunction

function namespace_name(name)
    return string.replace(name, "-|::")
endfunction

function option_default(option)
    define my.option = option_default.option

    if (!defined(my.option.default))
        abort("Missing expected default.")
    endif

    define my.result = ""

    if (my.option.default = "no")
        my.result = "OFF"
    elsif (my.option.default = "yes")
        my.result = "ON"
    else
        my.result = "$(my.option.default:upper)"
    endif

    return my.result
endfunction

function merge_components(dependencies, element)
    define my.dependencies = merge_components.dependencies
    define my.element = merge_components.element

    if (count(my.dependencies.dependency, dependency.name = my.element.name) > 0)
        define my.destination = my.dependencies->dependency(dependency.name = my.element.name)

        for my.element.component as _component
            if (count(my.destination.component, component.name = _component.name) = 0)
                copy _component to my.destination
            endif
        endfor
    else
        copy my.element to my.dependencies
    endif
endfunction

function dependency_discovery(repository)
    define my.repository = dependency_discovery.repository

    new discoverables as _disc
        for my.repository.library as _library
            for _library.dependency as _dep
                merge_components(_disc, _dep)
            endfor
        endfor
        for my.repository.test as _test
            for _test.dependency as _dep
                merge_components(_disc, _dep)
            endfor
        endfor
        for my.repository.binary as _binary
            for _binary.dependency as _dep
                merge_components(_disc, _dep)
            endfor
        endfor

        emit_find_dependencies(_disc)

        # detect fixups
        if (defined(_disc->dependency(dependency.name = "boost")) & \
            defined(_disc->dependency(dependency.name = "icu")))

            emit_boost_icu_fixups()
        endif
    endnew # _disc
endfunction

function accumulate_tests(target)
    define my.target = accumulate_tests.target
    define my.result = "*"

    if (count(my.target.trigger) > 0)
        my.result = ""
    endif

    for my.target.trigger as _trigger
        if (first())
            my.result = "$(_trigger.test)"
        else
            my.result = "$(my.result),$(_trigger.test)"
        endif
    endfor

    return my.result
endfunction

###############################################################################
# Macros
###############################################################################
.endtemplate
.template 1
.
.macro emit_CMakeLists(repository, root_path)
.   define my.repository = emit_CMakeLists.repository
.   define my.root_path = emit_CMakeLists.root_path
.
.   copyleft(my.repository.name)
cmake_minimum_required(VERSION 3.30 FATAL_ERROR)

project($(my.repository.name)
  VERSION $(my.repository.version)
  DESCRIPTION $(my.repository.description)
  LANGUAGES $(language_list(my.repository)))

list( APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/modules" )

if (MSVC)
  set( CMAKE_STATIC_LIBRARY_PREFIX "lib" )
  set( CMAKE_SHARED_LIBRARY_PREFIX "lib" )
endif()

.   heading("Project options.")
.   emit_repository_options(my.repository)

.   heading("Dependencies")
.   dependency_discovery(my.repository)
.
.   for my.repository.library as _library

.       heading("$(target_name(_library)) library")
.       emit_target(_library, my.repository, my.root_path)
.
.   endfor
.
.   for my.repository.test as _test

.       heading("$(target_name(_test)) tests")
.       emit_target(_test, my.repository, my.root_path)
.   endfor
.
.   for my.repository.binary as _binary

.       heading("$(target_name(_binary)) executable")
.       emit_target(_binary, my.repository, my.root_path)
.   endfor
.
.endmacro # emit_CMakeLists
.
.macro emit_repository_options(repository)
.   define my.repository = emit_repository_options.repository
.
.   for my.repository.library as _library
.       emit_options(_library)
.   endfor
.   for my.repository.test as _test
.       emit_options(_test)
.   endfor
.   for my.repository.binary as _binary
.       emit_options(_binary)
.   endfor
.endmacro # emit_repository_options
.
.macro emit_options(context)
.   define my.context = emit_options.context
.
.   if (defined(my.context.type))
option( $(my.context.type:lower)-$(my.context.option:lower) "Build $(my.context.option)." $(option_default(my.context)) )
.   endif
.
.   for my.context.option as _option
option( $(_option.type:lower)-$(_option.name:lower) $(_option.comment) $(option_default(_option)) )
.   endfor
.endmacro # emit_options
.
.macro emit_find_dependencies(dependencies)
.   define my.dependencies = emit_find_dependencies.dependencies
.
if (BUILD_SHARED_LIBS)
.   for my.dependencies.dependency as _dep
  set( $(package_name(_dep))_USE_STATIC_LIBS "OFF" )
.   endfor
else()
.   for my.dependencies.dependency as _dep
  set( $(package_name(_dep))_USE_STATIC_LIBS "ON" )
.   endfor
endif()
.
.   for my.dependencies.dependency as _dep
.       define has_components = (count(_dep.component) > 0)
.       define has_version = defined(_dep.version)
.

find_package( $(package_name(_dep)) $(defined(_dep.version) ?? "$(_dep.version) " ? "")REQUIRED$(has_components ?? "" ? " )")
.       if (has_components)
    COMPONENTS
.           for _dep.component as _component
      $(_component.name)
.           endfor
  )
.       endif
.   endfor
.endmacro # emit_find_dependencies
.
.macro emit_boost_icu_fixups()

if (with-icu)
  include(InTargetProperty)
  remove_in_target_property( Boost::locale INTERFACE_LINK_LIBRARIES icudata )
  remove_in_target_property( Boost::locale INTERFACE_LINK_LIBRARIES icui18n )
  remove_in_target_property( Boost::locale INTERFACE_LINK_LIBRARIES icuuc )
endif()
.endmacro # emit_boost_icu_fixups
.
.macro emit_add_test(target, indent)
.   define my.target = emit_add_test.target
.   define my.indent = emit_add_test.indent
.   define my.tests = accumulate_tests(my.target)
.

$(my.indent)enable_testing()

$(my.indent)add_test( NAME $(target_name(my.target))
  $(my.indent)COMMAND $(target_name(my.target))
  $(my.indent)--run_test=$(my.tests)
  $(my.indent)--log_level=warning
  $(my.indent)--show_progress=no
  $(my.indent)--detect_memory_leak=0
  $(my.indent)--report_level=no
  $(my.indent)--build_info=yes
.
.endmacro # emit_add_test
.
.macro emit_target(target, repository, root_path)
.   define my.target = emit_target.target
.   define my.repository = emit_target.repository
.   define my.indent = defined(my.target.option) ?? "  " ? ""
.
.   if (defined(my.target.option))
if ($(my.target.type:lower)-$(my.target.option:lower))
.   endif
.
.   if (name(my.target) = "library")
$(my.indent)add_library( $(target_name(my.target)) )
$(my.indent)add_library( $(qualified_target_name(my.target))) ALIAS $(target_name(my.target)) )
.   else
$(my.indent)add_executable( $(target_name(my.target)) )
.   endif
.
.   if (name(my.target) = "test")
.       emit_add_test(my.target, my.indent)
.   endif
.
.   emit_target_sources(my.target, my.indent)
.
.   emit_target_headers(my.target, my.indent)
.
.   emit_target_link_libraries(my.target, my.indent)
.
.   if (defined(my.target.option))
endif()
.   endif
.endmacro # emit_target
.
.macro emit_target_link_libraries_parameterized(target, mode, indent)
.   define my.target = emit_target_link_libraries_parameterized.target
.   define my.mode = emit_target_link_libraries_parameterized.mode
.   define my.indent = emit_target_link_libraries_parameterized.indent
.
.   if (count(my.target.dependency, (my.mode = "PRIVATE") ?? \
      defined(dependency.private) ? !defined(dependency.private)) > 0)

target_link_libraries( $(target_name(my.target))
  $(my.mode:upper)
.       for my.target.dependency as _dep where (my.mode = "PRIVATE") ?? \
          defined(_dep.private) ? !defined(_dep.private)
.           if (count(_dep.component) > 0)
.               for _dep.component as _comp
    $(qualified_component_name(_dep, _comp))
.               endfor
.           else
    $(qualified_target_name(_dep))
.           endif
.       endfor
)

.   endif
.endmacro # emit_target_link_libraries_parameterized
.
.macro emit_target_link_libraries(target, indent)
.   define my.target = emit_target_link_libraries.target
.   define my.indent = emit_target_link_libraries.indent
.
.
.   emit_target_link_libraries_parameterized(my.target, "PUBLIC", my.indent)
.   emit_target_link_libraries_parameterized(my.target, "PRIVATE", my.indent)
.
.endmacro # emit_target_link_libraries
.
.macro emit_target_sources(target, indent)
.endmacro # emit_target_sources
.
.macro emit_target_headers(target, indent)
.endmacro # emit_target_headers
.
.endtemplate
.template 0
###############################################################################
# Generation
###############################################################################
.endtemplate
.template 0
function generate_CMakeLists(configuration)
    define my.configuration = generate_CMakeLists.configuration
    require(my.configuration->templates, "templates", "resultpath")

    define template = my.configuration->templates->template(name = "CMakeLists.txt.gsl")

    if (!defined(template))
        abort "Generator configuration missing."
    endif

    require(template, "template", "outpath")
    require(template->cmake, "cmake", "rootpath")

    define my.project_path_suffix = template.outpath
    define my.root_path = template->cmake.rootpath

    for my.configuration.repository by name as _repository
        require(_repository, "repository", "name")
        define my.output_path = path_append(\
            my.configuration->templates.resultpath, \
            path_append(my.path_prefix, \
                path_append(_repository.name, my.project_path_suffix)))

        create_directory(my.output_path)

        define my.out_file = path_append(my.output_path, "CMakeLists.txt")
        notify(my.out_file)
        output(my.out_file)

        emit_CMakeLists(_repository, my.root_path)

        close
     endfor _repository
endfunction # generate_CMakeLists

###############################################################################
# Execution
###############################################################################
[global].root = ".."
[global].trace = 0
[gsl].ignorecase = 0

# Note: expected context root libbitcoin-build directory
gsl from "../lib/debug.gsl"
gsl from "../lib/filesystem.gsl"
gsl from "../lib/output.gsl"
gsl from "../lib/cmake.gsl"

generate_CMakeLists(configuration)

.endtemplate
